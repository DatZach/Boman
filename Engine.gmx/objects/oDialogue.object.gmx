<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>0</visible>
  <depth>-50001</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Initialize dialogue

// CONSTANTS
DIALOGUE_SPEED = 100 / room_speed;

enum DSide {
    Left,
    Right
}

// Colors
outlineColor = make_color_rgb(107, 126, 136);
selectColor = make_color_rgb(103, 161, 219);
blackColor = make_color_rgb(28, 30, 32);
whiteColor = make_color_rgb(252, 250, 233);

// Dialogue Variables
surf = -1;
dialogue = ds_list_create();
segments = ds_list_create();
diagIndex = 0;
charIndex = 0;
prevCharIndex = 0;
doubleTap = false;
waiting = false;
canWait = true;
awaitingKey = false;                                    // NOTE This is purely for visuals
optionIndex = 0;
backdrop = noone;
windowOffset = 0;

portrait[DSide.Left] = noone;
portrait[DSide.Right] = noone;
portraitFrame[DSide.Left] = 0;
portraitFrame[DSide.Right] = 0;
namePlate[DSide.Left] = '';
namePlate[DSide.Right] = '';

intensity = 0;
targetIntensity = 0.7;

alarm[0] = 1;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="1" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Cleanup resources

var count = ds_list_size(dialogue);
for(var i = 0; i &lt; count; ++i)
    ds_map_destroy(dialogue[| i]);

ds_list_destroy(dialogue);

count = ds_list_size(segments);
for(var i = 0; i &lt; count; ++i)
    ds_map_destroy(segments[| i]);

ds_list_destroy(segments);

if (surface_exists(surf))
    surface_free(surf);

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="2">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Text delay cooldown

waiting = false;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="1">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Reset double tap

doubleTap = false;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Finish dialogue initialization

if (ds_list_size(dialogue) &lt;= 0)
{
    ConsolePrint(oController.debugConsole, 'Dialogue was not initialized with any content.');
    exit;
}

var entry = dialogue[| 0];
var side = entry[? 'side'];
portrait[side] = entry[? 'portrait'];
portraitFrame[side] = 0;
namePlate[side] = entry[? 'name'];

visible = true;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Update dialogue

// Update intensity
intensity = lerp(intensity, targetIntensity, 0.25);
if (intensity &lt;= 0.1 &amp;&amp; targetIntensity == 0)
    instance_destroy();
    
if (targetIntensity == 0)
    exit;

// HANDLE DIALOGUE LOGIC
var segment;
if (ds_list_empty(segments))
{
    var newSegment = ds_map_create();
        newSegment[? 'type'] = 0;
        newSegment[? 'text'] = '';
        newSegment[? 'text-color'] = blackColor;
        newSegment[? 'sprite'] = -1;
        newSegment[? 'image-index'] = 0;
    ds_list_add(segments, newSegment);
    segment = newSegment;
}
else
    segment = segments[| ds_list_size(segments) - 1];

var entry = dialogue[| diagIndex];
var type = entry[? 'type'];
var text = entry[? 'value'];
var textLength = string_length(text);
var actionHold = CheckKey(global.k_action, E_DOWN);
var actionPress = CheckKey(global.k_action, E_PRESS);

for(var i = prevCharIndex; i &lt; floor(charIndex); ++i)
{
    var ch = string_char_at(text, i + 1);
    if (ch == '\')
    {
        var nch = string_char_at(text, i + 2);
        switch(nch)
        {
            case '.':
                prevCharIndex = i;
                awaitingKey = true;
                if (!actionPress)
                    exit;
                    
                charIndex += 2;
                ++i;
                break;
                
            case 'z':
                if (!waiting &amp;&amp; canWait)
                {
                    prevCharIndex = i;
                    waiting = true;
                    canWait = false;
                    alarm[2] = room_speed * 0.5;
                    exit;
                }
                else if (alarm[2] &gt; 0)
                    exit;
                else
                {
                    canWait = true;
                    charIndex += 2;
                    ++i;
                    break;
                }
                exit;
                
            case '$':
            {
                var spriteName = '';
                var imageIndex = 0;
                i += 3;
                
                var ch;
                for(; i &lt; textLength; ++i)
                {
                    ch = string_char_at(text, i);
                    if (ch == '$' || ch == ':')
                        break;
                    
                    spriteName += ch;
                }
                
                if (ch == ':')
                {
                    var strImageIndex = '';
                    
                    ++i;
                    for(; i &lt; textLength; ++i)
                    {
                        ch = string_char_at(text, i);
                        if (ch == '$')
                            break;
                        
                        strImageIndex += ch;
                    }
                    
                    imageIndex = real(strImageIndex);
                }
                
                var sprIndex = asset_get_index(spriteName);
                var newSegment = ds_map_create();                   // Sprite segment
                    newSegment[? 'type'] = 1;
                    newSegment[? 'text'] = '';
                    newSegment[? 'text-color'] = blackColor;
                    newSegment[? 'sprite'] = sprIndex;
                    newSegment[? 'image-index'] = imageIndex;
                ds_list_add(segments, newSegment);
                newSegment = ds_map_create();                       // Return back to text
                    newSegment[? 'type'] = 0;
                    newSegment[? 'text'] = '';
                    newSegment[? 'text-color'] = blackColor;
                    newSegment[? 'sprite'] = -1;
                    newSegment[? 'image-index'] = 0;
                ds_list_add(segments, newSegment);
                segment = newSegment;
                charIndex = i;
                
                if (sprIndex == -1)
                    ConsolePrint(oController.debugConsole, concat('Unable to resolve sprite "', spriteName, '"'));
                break;
            }
            
            case '@':
            {
                i += 3;
                var hexCode = string_copy(text, i, 6);
                i += 5;
                
                newSegment = ds_map_create();
                    newSegment[? 'type'] = 0;
                    newSegment[? 'text'] = '';
                    newSegment[? 'text-color'] = make_color_hex(hexCode);
                    newSegment[? 'sprite'] = -1;
                    newSegment[? 'image-index'] = 0;
                ds_list_add(segments, newSegment);
                segment = newSegment;
                charIndex = i;
                break;
            }
            
            case '!':
            {
                i += 2;
                newSegment = ds_map_create();
                    newSegment[? 'type'] = 0;
                    newSegment[? 'text'] = '';
                    newSegment[? 'text-color'] = blackColor;
                    newSegment[? 'sprite'] = -1;
                    newSegment[? 'image-index'] = 0;
                ds_list_add(segments, newSegment);
                segment = newSegment;
                charIndex = i;
                break;
            }
                
            case '0':
            case '1':
            case '2':
            case '3':
            case '4':
            case '5':
            case '6':
            case '7':
            case '8':
            case '9':
                portraitFrame[entry[? 'side']] = real(nch);
                ++i;
                break;
        }
    }
    else
    {
        segment[? 'text'] += ch;
    }
}

awaitingKey = false;
prevCharIndex = floor(charIndex);

if (charIndex &lt;= textLength)
{
    if (actionPress &amp;&amp; doubleTap)
        charIndex = textLength;
    else
        charIndex += DIALOGUE_SPEED + DIALOGUE_SPEED * actionHold;
    
    if (actionHold)
    {
        doubleTap = true;
        alarm[1] = room_speed * 0.33;
    }
}
else if (CheckKey(global.k_action, E_PRESS))
{
    // Execute whatever script is attached to this dialogue
    var script = entry[? 'script'];
    if (script != noone)
    {
        if (type == 1)
            script_execute(script, self, optionIndex);
        else
            script_execute(script);
    }
    
    // Move to next entry
    //segment = '';
    var count = ds_list_size(segments);
    for(var i = 0; i &lt; count; ++i)
        ds_map_destroy(segments[| i]);
    ds_list_clear(segments);
    ++diagIndex;
    
    // DESTROY DIALOGUE IF WE'VE REACHED THE END
    if (diagIndex &gt;= ds_list_size(dialogue))
    {
        targetIntensity = 0;
        exit;
    }
    
    entry = dialogue[| diagIndex];
    var side = entry[? 'side'];
    portrait[side] = entry[? 'portrait'];
    namePlate[side] = entry[? 'name'];
    
    charIndex = 0;
    prevCharIndex = 0;
    optionIndex = 0;
    windowOffset = 0;
}

if (type == 1)
{
    if (CheckKey(global.k_down, E_PRESS))
        optionIndex += 2;
    else if (CheckKey(global.k_up, E_PRESS))
        optionIndex -= 2;
    else if (CheckKey(global.k_right, E_PRESS))
        ++optionIndex;
    else if (CheckKey(global.k_left, E_PRESS))
        --optionIndex;
    
    var count = entry[? 'option-count'];
    if (optionIndex &lt; 0)
        optionIndex = count - 1;
    else if (optionIndex &gt;= count)
        optionIndex = 0;
    
   if (optionIndex &lt; windowOffset)
        windowOffset -= 2;
    
    if (optionIndex &gt;= windowOffset + 4)
        windowOffset += 2;
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="64">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Draw overlay - Dialogue

var OFFSET = 12;

var width = display_get_gui_width();
var height = display_get_gui_height();
var left = OFFSET;
var top = OFFSET;
var right = width - OFFSET;
var bottom = height - OFFSET;
var dialogueTop = floor(bottom - height * 0.25);

// Obscure game world
draw_set_color(c_black);
draw_set_alpha(intensity);
draw_rectangle(0, 0, width, height, false);

if (backdrop != noone)
{
    draw_set_alpha(intensity / targetIntensity);
    draw_background(backdrop, 0, 0);
}

draw_set_alpha(1);

if (targetIntensity == 0)
    exit;

var entry = dialogue[| diagIndex];
var type = entry[? 'type'];
var side = entry[? 'side'];
    
// Character Portrait
if (portrait[DSide.Left] != noone)
{
    var name = namePlate[DSide.Left];
    
    draw_sprite_ext(
        portrait[DSide.Left],
        portraitFrame[DSide.Left],
        left + OFFSET,
        top,
        1, 1, 0,
        iff(name == '???', c_black, iff(side == DSide.Left, c_white, c_gray)),
        1
    );
    
    // Name Plate
    draw_set_font(fDialog_NamePlate);
    
    var nameWidth = string_width(name);
    var nameHeight = string_height(name);
    
    draw_set_color(blackColor);
    draw_roundrect_ext(
        left + 150 - nameWidth / 2 - 14,
        dialogueTop - 16 - nameHeight / 2 - 2,
        left + 150 + nameWidth / 2 + 14,
        dialogueTop - 16 + nameHeight / 2 + 2,
        2, 2, false
    );
    
    draw_set_color(c_orange);
    draw_set_halign(fa_center);
    draw_set_valign(fa_middle);
    draw_text(left + 150, dialogueTop - 16, name);
    draw_set_valign(fa_top);
    draw_set_halign(fa_left);
}

if (portrait[DSide.Right] != noone)
{
    var name = namePlate[DSide.Right];
    
    draw_sprite_ext(
        portrait[DSide.Right],
        portraitFrame[DSide.Right],
        right - OFFSET - sprite_get_width(portrait[DSide.Right]),
        top,
        1, 1, 0,
        iff(name == '???', c_black, iff(side == DSide.Right, c_white, c_gray)),
        1
    );
    
    // Name Plate
    draw_set_font(fDialog_NamePlate);
    
    var nameWidth = string_width(name);
    var nameHeight = string_height(name);
    
    draw_set_color(blackColor);
    draw_roundrect_ext(
        right - 150 - nameWidth / 2 - 14,
        dialogueTop - 16 - nameHeight / 2 - 2,
        right - 150 + nameWidth / 2 + 14,
        dialogueTop - 16 + nameHeight / 2 + 2,
        2, 2, false
    );
    
    draw_set_color(c_orange);
    draw_set_halign(fa_center);
    draw_set_valign(fa_middle);
    draw_text(right - 150, dialogueTop - 16, name);
    draw_set_valign(fa_top);
    draw_set_halign(fa_left);
}

// Dialogue Box
draw_set_color(whiteColor);
draw_roundrect_ext(left, dialogueTop, right, bottom, 2, 2, false);
draw_set_color(blackColor);
draw_roundrect_ext(left, dialogueTop, right, bottom, 2, 2, true);

var LINE_COUNT = 4;
var lineHeight = string_height('M') + 5;
var dialogueWidth = (right - left - OFFSET * 2);
var dialogueHeight = lineHeight * LINE_COUNT;
var markerX = -1;
var markerY = -1;

if (!surface_exists(surf))
{
    surf = surface_create(dialogueWidth, dialogueHeight * 10);
}

surface_set_target(surf);
draw_clear(whiteColor);

if (type == 0)
{
    // Dialogue Text
    draw_set_font(fDialogue);
    
    var text = entry[? 'value'];
    var tx = 0;
    
    for(var i = 0; i &lt; ds_list_size(segments); ++i)
    {
        var ty = floor(tx / dialogueWidth) * lineHeight;

        var segment = segments[| i];
        switch(segment[? 'type'])
        {
            
            case 0:
            {
                var partialText = segment[? 'text'];
                var xx = tx % dialogueWidth;
                tx += string_width(partialText);
                var yy = ty;
                
                draw_set_color(segment[? 'text-color']);
                
                if (xx &gt; 0)
                {
                    var chunk0 = '';
                    var j = 1;
                    for(; j &lt;= string_length(partialText) &amp;&amp;
                        string_width(chunk0) + xx &lt; dialogueWidth;
                        ++j)
                    {
                        chunk0 += string_char_at(partialText, j);
                    }
                    
                    var chunk1 = string_copy(partialText, j, string_length(partialText) - j);
                    draw_text(xx, yy, chunk0);
                    draw_text_ext(0, yy + lineHeight, chunk1, lineHeight, dialogueWidth);
                }
                else
                    draw_text_ext(xx, yy, partialText, lineHeight, dialogueWidth);
                
                break;
            }
            
            case 1:
            {
                var sprite = segment[? 'sprite'];
                var imageIndex = segment[? 'image-index'];
                
                var spaceWidth = 1;
                var xx = tx % dialogueWidth + sprite_get_xoffset(sprite) + spaceWidth;
                tx += sprite_get_width(sprite) + spaceWidth * 2;
                var yy = ty + sprite_get_yoffset(sprite);
                
                draw_sprite(sprite, imageIndex, xx, yy);                
                break;
            }
            
        }
    }
    
    // Waiting Key Toast
    if (awaitingKey || charIndex &gt;= string_length(text))
    {
        var ty = floor(tx / dialogueWidth) * lineHeight + 3;
        var xx = tx % dialogueWidth + OFFSET + 6;
        var yy = ty + 6;
        
        markerX = xx;
        markerY = yy;
    }
}
else
{
    // Options
    draw_set_color(blackColor);
    draw_set_font(fDialogue);
    
    var text = entry[? 'value'];
    var tx = 0;
    var ty = 0;
    
    for(var i = 0; i &lt; ds_list_size(segments); ++i)
    {
        var segment = segments[| i];
        var partialText = segment[? 'text'];
        draw_text_ext(0, 0, partialText, -1, right - left - OFFSET * 2);
    }
    
    if (charIndex &gt;= string_length(text))
    {
        var count = min(4, entry[? 'option-count'] - windowOffset);
        for(var i = 0; i &lt; count; ++i)
        {
            var ii = i + windowOffset;
            var xx = OFFSET + OFFSET + floor(i % 2) * ((right - left - OFFSET * 4) / 2) + 16;
            var yy = OFFSET + lineHeight + floor(i / 2) * ((bottom - dialogueTop - OFFSET * 4) / 2);
            
            draw_text(xx, yy, entry[? concat('option_', ii)]);

            if (ii == optionIndex)
            {
                markerX = xx - 16;
                markerY = yy + 9;
            }
        }
    }
}

surface_reset_target();
var to = max(0, (ceil(tx / dialogueWidth) - 4) * lineHeight);
draw_surface_part(
    surf,
    0, to,
    dialogueWidth, dialogueHeight,
    left + OFFSET, dialogueTop + OFFSET
);

if (markerX != -1 &amp;&amp; markerY != -1)
{
    draw_sprite_ext(
        sDialogueFinishMarker, 0,
        left + OFFSET + markerX, dialogueTop + OFFSET + markerY - to,
        1, 1,
        get_timer() / 30000,
        c_black, 0.66
    );
    
    draw_sprite_ext(
        sDialogueFinishMarker, 0,
        left + OFFSET + markerX, dialogueTop + OFFSET + markerY - to - abs(sin(get_timer() / 600000) * 4),
        1, 1,
        get_timer() / 30000,
        c_white, 1
    );
}

draw_sprite_ext(
    sDialogueQuoteMark,
    0,
    iff(side == DSide.Left, left + 200, right - 200),
    dialogueTop,
    iff(side == DSide.Left, 1, -1),
    1, 0, c_white, 1
);

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
