<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>0</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>pStaticSolid</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>604</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_inherited</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
      </action>
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Platforming Initialization

PLAYER_NUMBER = 0;

dir = 1;               // Player direction. 1 = right, -1 = left.
xspeed = 0.0;          // Horizontal speed.
yspeed = 0.0;          // Vertical speed.
xmaxspeed = 3.0;       // Horizontal speed limit.
ymaxspeed = 8.0;       // Vertical speed limit.

weight = 0.4;          // How fast the player falls.
accel = 1.5;           // How fast the player accelerates horizontally.
xfriction = 1.0;       // How fast the player decelerates horizontally.
jumpHeight = 6.5;      // How high the player jumps.

maxDoubleJumps = 1;    // Number of possible additional jumps. 
availableJumps = 0;    // Number of available additional jumps.
maxWallJumps = 2;
availableWallJumps = 0;
canDoubleJump = false; // Whether or not player can do an additional jump.
canWalljump = true;    // Whether or not player can walljump.

isClimbing = false;    // Whether or not player is climbing.
isJumping = false;     // Whether or not player is jumping.
isDismounting = false; // Whether or not player is dismounting a ladder.
isWallsliding = false; // Whether or not player is sliding down a wall.
isLedgeGrabbing = false;

dismount_max = 20;     // Max number of ladder dismounting frames.
landing_max = 10;      // Max number of landing frames.

dismount = 0;          // Remaining number of ladder dismounting frames.
landing = 0;           // Remaining number of landing frames.

xsave = 0;
ysave = 0;

dynPlatformLedgeGrabInst = noone;

</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/// Platforming Logic

if (global.gamePaused) exit;

var jtColliding = false;

// Track previous x/y
px = x;
py = y;

// VELOCITY HANDLING ==================================================

// Clamp velocities
var absXSpeed = abs(xspeed);
if (absXSpeed &gt; xmaxspeed)
{
    if (absXSpeed - xmaxspeed &lt; 1)
        xspeed = xmaxspeed * sign(xspeed);
    else
    {
        xspeed = lerp(xspeed, xmaxspeed * sign(xspeed), 0.01);
    }
}

var absYSpeed = abs(yspeed);
if (absYSpeed &gt; ymaxspeed)
{
    if (absYSpeed - ymaxspeed &lt; 1)
        yspeed = ymaxspeed;
    else
        yspeed = lerp(yspeed, ymaxspeed * sign(yspeed), 0.1);
}

if (isLedgeGrabbing)
    yspeed = 0;

var colInst = instance_place(x, y + 4, pDynamicSolid);
if (colInst != noone || dynPlatformLedgeGrabInst != noone) {
    // ON TOP OF A DYNAMIC SOLID (MOVING PLATFORMS)
    
    if (yspeed &gt; 0)
        yspeed = 0;
    
    if (colInst == noone)
        colInst = dynPlatformLedgeGrabInst;
        
    x += xspeed + colInst.x - colInst.px;
    y += yspeed + colInst.y - colInst.py;
    x = floor(x);
    y = floor(y);
    
    if (place_meeting(x + xspeed, y, pStaticSolid)) {
        x -= xspeed + colInst.x - colInst.px;
        xspeed = 0;
    }
    
    if (dynPlatformLedgeGrabInst == noone)
        move_contact_solid(270, 4);
    else if (!place_meeting(x + 4 * dir, y, pDynamicSolid)) {
        isLedgeGrabbing = false;
        dynPlatformLedgeGrabInst = noone;
    }
}
else {
    // Everything else
    
    // 1. VERTICAL VELOCITY
    if (yspeed &gt;= 0 &amp;&amp; collision_rectangle(bbox_left, bbox_bottom, bbox_right, bbox_bottom + yspeed + 1, pJumpThrough, false, true) != noone) {
        // ON TOP OF JUMP-THROUGH PLATFORM
        if (yspeed &gt; 0) {
            isClimbing = false;
            isJumping = false;
            isDismounting = false;
            landing = landing_max;
            dismount = dismount_max;
            y = floor(y);
        }
        
        move_contact_all(point_direction(x, y, x, y + yspeed + 1), yspeed + 1);
        yspeed = 0;
        jtColliding = true;
    }
    else {
        // IN AIR OR COLLIDING WITH STATIC SOLID (BLOCKS)
        
        // HACK This is a bullshit hack to fix mobs not handling collisions with other mobs and the player correctly
        var _inst = instance_place(x, y + yspeed, pStaticSolid);
        if (_inst == noone || _inst == oPlayer.id || object_is_ancestor(_inst.object_index, pMob)) {
              y += yspeed;
        }
        else {
            // Landing.
            if (yspeed &gt; 0) {
                isClimbing = false;
                isJumping = false;
                isDismounting = false;
                landing = landing_max;
                dismount = dismount_max;
                y = floor(y);
            }
            
            move_contact_solid(point_direction(x, y, x, y + yspeed), yspeed);
          
            if (place_meeting(x, y, pStaticSolid))
                move_outside_solid(point_direction(x, y, x, y - max(yspeed, 4)), max(yspeed, 4));
            
            yspeed = 0;
        }
    }
    
    // Horizontal Velocity
    var xSign = sign(xspeed);
    if (xspeed &gt; 0)
        xsave += xspeed - floor(xspeed);
    else if (xspeed &lt; 0)
        xsave += abs(xspeed - ceil(xspeed));
    
    if (xsave &gt;= 1)
        xsave = -1;
    
    var xrep = abs(xspeed);
    if (xsave == -1)
    {
        ++xrep;
        xsave = 0;
    }
    
    xrep = floor(xrep);
    
    repeat(xrep) {
        if (!place_meeting(x + xSign, y + 1, pStaticSolid) &amp;&amp;
             place_meeting(x + xSign, y + 2, pStaticSolid)) {
            // SLOPE DOWN
            // if (id == oPlayer.id) show_debug_message('hspd - slope down');
            x += sign(xspeed);
            y += 1;
        }
        else {
            // HACK This is a bullshit hack to fix mobs not handling collisions with other mobs and the player correctly
            var _inst = instance_place(x + xSign, y, pStaticSolid);
            var horzOnlyCollision = _inst != noone &amp;&amp;
                                    _inst != oPlayer.id &amp;&amp;
                                    _inst.solid; //!object_is_ancestor(_inst.object_index, pMob);
            
            if (_inst != noone &amp;&amp; !place_meeting(x + xSign, y - 1, pStaticSolid)) {
                // SLOPE UP
                // if (id == oPlayer.id) show_debug_message('hspd - slope up');
                x += sign(xspeed);
                y -= 1;
            }
            else if (!horzOnlyCollision) {
                // LEFT-RIGHT FREE
                // if (id == oPlayer.id) show_debug_message('hspd - left/right free');
                x += sign(xspeed);
            }
            else {
                // COLLIDING WITH SOLID
                
                // if (id == oPlayer.id) show_debug_message('hspd - colliding with solid');
                
                // HACK This if statement fixes mobs being treated as solid objects
                //      if there's a way to properly fix this in the future it would be better
                //      We have retarded collision checks in place otherwise
                var _mobInst = instance_place(x + xSign, y, pMob);
                if (_inst != oPlayer.id &amp;&amp; (_mobInst != noone &amp;&amp; _mobInst.solid))
                    move_contact_solid(point_direction(x, y, x + xspeed, y), xspeed);
                    
                xspeed = 0;
                break;
            }
        }
        
        x = floor(x);
    }
}

// ENVIRONMENT INTERACTIONS

isWallsliding = false;

if (isClimbing == false) {
    var prevDir = dir;
  
    // Handle directions
    if (key_check(K_LEFT, E_PRESS) || (key_check(K_LEFT, E_DOWN) &amp;&amp; key_check(K_RIGHT, E_RELEASE))) {
        dir = -1;
    }
    
    if (key_check(K_RIGHT, E_PRESS) || (key_check(K_RIGHT, E_DOWN) &amp;&amp; key_check(K_LEFT, E_RELEASE))) {
        dir = 1; 
    }
  
    // Ledge Grabbing
    if (isLedgeGrabbing &amp;&amp; prevDir != dir) {
        // JUMP ACROSS FROM LEDGE GRAB
        isLedgeGrabbing = false;
        dynPlatformLedgeGrabInst = noone;
        xspeed = xmaxspeed * 4 * dir;
        yspeed = -jumpHeight;
        isJumping = true;
    }
    else if (isLedgeGrabbing &amp;&amp; key_check(K_JUMP, E_DOWN)) {
        // JUMP UP FROM LEDGE GRAB
        isLedgeGrabbing = false;
        dynPlatformLedgeGrabInst = noone;
        yspeed = -jumpHeight;
        isJumping = true;
    }
    else if (isLedgeGrabbing &amp;&amp; key_check(K_DOWN, E_DOWN)) {
        // DROP DOWN FROM LEDGE GRAB
        isLedgeGrabbing = false;
        dynPlatformLedgeGrabInst = noone;
    }
  
    // Jumping from air
    var floorCollision = place_meeting(x, y + 1, pStaticSolid);
    if (!floorCollision &amp;&amp; !jtColliding) {
        // CURRENTLY IN THE AIR
        yspeed += weight;
    
        if (!key_check(K_JUMP, E_DOWN)) {
            canDoubleJump = true;
        }
    
        // Wall jump
        var rightStaticSolidCol = place_meeting(x + 4, y, pStaticSolid);
        var leftStaticSolidCol = place_meeting(x - 4, y, pStaticSolid);
        
        if (availableWallJumps &gt; 0 &amp;&amp; canWalljump &amp;&amp; key_check(K_JUMP, E_PRESS)) {
            if (rightStaticSolidCol) {
                xspeed = -xmaxspeed * 4;
                yspeed = -jumpHeight;
                isJumping = true;
            }
      
            if (leftStaticSolidCol) {
                xspeed = xmaxspeed * 4;
                yspeed = -jumpHeight;
                isJumping = true;
            }
            
            --availableWallJumps;
        }
        
        // Wall slide
        
        if (rightStaticSolidCol &amp;&amp; key_check(K_RIGHT, E_DOWN) ||
            leftStaticSolidCol &amp;&amp; key_check(K_LEFT, E_DOWN)) {
            
            if ((dir == -1 &amp;&amp; collision_point(bbox_left  - 4, bbox_top - 3, pStaticSolid, false, true) == noone &amp;&amp; collision_point(bbox_left  - 4, bbox_top, pStaticSolid, false, true) != noone) ||
                (dir ==  1 &amp;&amp; collision_point(bbox_right + 4, bbox_top - 3, pStaticSolid, false, true) == noone &amp;&amp; collision_point(bbox_right + 4, bbox_top, pStaticSolid, false, true) != noone))
            {
                isLedgeGrabbing = true;
                dynPlatformLedgeGrabInst = instance_place(x + 4 * dir, y, pDynamicSolid);
            }
            else if (yspeed &gt; ymaxspeed / 6) {
                isWallsliding = true;
                yspeed = ymaxspeed / 6;
            }
        }
        // Double jump
        else if (availableJumps &gt; 0 &amp;&amp; key_check(K_JUMP, E_PRESS) &amp;&amp; canDoubleJump == true) {
            --availableJumps;
            yspeed = -jumpHeight;
            xspeed = xmaxspeed * (0 - key_check(K_LEFT, E_DOWN) + key_check(K_RIGHT, E_DOWN));
            isJumping = true;
        }
        
        // Jump cancel
        var jumpHeightHalf = -jumpHeight * 0.5;
        if (!key_check(K_JUMP, E_DOWN) &amp;&amp; isJumping &amp;&amp; yspeed &lt; jumpHeightHalf) {
            yspeed = jumpHeightHalf;
        }
    }
    // Jumping from ground
    else {
        availableJumps = maxDoubleJumps;
        availableWallJumps = maxWallJumps;
        canDoubleJump = false;
        
        if (key_check(K_JUMP, E_PRESS)) {
            yspeed = -jumpHeight;
            xspeed = xmaxspeed * (0 - key_check(K_LEFT, E_DOWN) + key_check(K_RIGHT, E_DOWN));
            isJumping = true;
        }
    }
      
    // Horizontal acceleration.
    if (key_check(K_LEFT, E_DOWN) &amp;&amp; xspeed &gt; -xmaxspeed &amp;&amp; dir == -1) {
        xspeed -= accel;
    }
    
    if (key_check(K_RIGHT, E_DOWN) &amp;&amp; xspeed &lt; xmaxspeed &amp;&amp; dir == 1) {
        xspeed += accel;
    }
      
    // Horizontal friction.
    if (!key_check(K_LEFT, E_DOWN) &amp;&amp; !key_check(K_RIGHT, E_DOWN)) {
        if (abs(xspeed) &gt; xfriction) {
            xspeed -= sign(xspeed) * xfriction;
        } else {
            xspeed = 0;
        }
    }
      
    // Climbing on to ladder.
    if (place_meeting(x, y, pClimbable) &amp;&amp; !isDismounting) {
        if (key_check(K_UP, E_DOWN) &amp;&amp; place_meeting(x, y - 8, pClimbable)) {
            isClimbing = true;
            dismount = dismount_max;
        }
        
        if (key_check(K_DOWN, E_DOWN) &amp;&amp; place_meeting(x, y + 8, pClimbable) &amp;&amp; !floorCollision) {
            isClimbing = true;
            dismount = dismount_max;
        }
    }
    // Drop from jump-through platforms
    else if (key_check(K_DOWN, E_DOWN) &amp;&amp; yspeed == 0 &amp;&amp; jtColliding &amp;&amp; !floorCollision)
        y += 1;
}
// Movement on ladder:
else {
    xspeed = 0;
    yspeed = 0;
  
    // Stop climbing.
    if (!place_meeting(x, y, pClimbable)) {
        isClimbing = false;
    }
  
    // Handle direction.
    if (key_check(K_LEFT, E_PRESS)) {
        dir = -1;
    }
     
    if (key_check(K_RIGHT, E_PRESS)) {
        dir = 1;
    }
  
    if ((key_check(K_LEFT, E_DOWN) || key_check(K_RIGHT, E_DOWN)) &amp;&amp; place_meeting(x + dir, y, pClimbable)) {
        xspeed += 2 * dir;
        dismount = dismount_max;
    }
    else if ((key_check(K_LEFT, E_DOWN) || key_check(K_RIGHT, E_DOWN)) &amp;&amp; !place_meeting(x + dir, y, pClimbable)) {
        // Dismounting counter.      
        dismount -= 1;
    }
    else {
        dismount = dismount_max;
    }
  
    // Go down the ladder.
    if (place_meeting(x, y+8, pClimbable) &amp;&amp; key_check(K_DOWN, E_DOWN)) {
        yspeed = 2.0;
        
        if (place_meeting(x, y+1, pStaticSolid) || jtColliding) {
            is_climbing = false;
        }
    }
    
    // Go up the ladder.
    if (place_meeting(x, y-8, pClimbable) &amp;&amp; key_check(K_UP, E_DOWN)) {
        yspeed = -2.0;
    }
  
    // Dismounting.
    if ((key_check(K_UP, E_PRESS) &amp;&amp; !place_meeting(x, y - 8, pClimbable)) || dismount &lt;= 0) {
        isClimbing = false;
        isDismounting = true;
        if (dismount &lt;= 0) {
            xspeed = (xmaxspeed / 2) * dir;
        }
        
        if (!key_check(K_DOWN, E_DOWN)) {
            yspeed = -6;
        }
    }
}

</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
